---
title: "trajectory analysis"
output: html_notebook
date: "25/08/21"
author: "Finlay Slorach"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading data


```{r message=FALSE, warning=FALSE}
############ LOAD DATA ##############
root <- '/hpc/scratch/hdd2/fs541623/scRNAseq/Run1_3_Cisplatin_080721/Secondary_analysis'
s <- readRDS(paste0(root, '/new_SCE_objects/FINAL_WORKFLOW/DE_obj.rds'))
theme_set(theme_bw())
```

Here we get the corrected counts. Convert the counts to a single cell experiment object as a downstream package works best with SCE object. We also run MDS again and specify we 10 components as output and convert it to a dataframe for plotting. 

```{r}
######################## TRAJECTORY ANALYSIS ########################
counts <- GetAssayData(s, assay='SCT', slot='scale.data')
sce <- SingleCellExperiment(list(logcounts=GetAssayData(s, assay='SCT', slot='scale.data')))
sce$sample <- s$sample
sce$day <- s$day
## get mds components ##
d <- dist(t(GetAssayData(s, slot = "scale.data")))
mds <- cmdscale(d = d, k = 10) 
mds.df <- as.data.frame(mds)
mds.df$sample <- s$sample
```

## Non linear dimensionality reduction

Diffusion maps are a non linear dimensionality reduction technique compared to PCA and MDS which are linear dimensionality reduction techniques. Therefore, diffusion maps in theory can capture more complex relationships between variables. They are also most appropriate for time course data such as this. Other popular non linear dimensonality reduction techniques are tSNE and UMAP which work well when you have > 1000s of cells 

Here we input 5 MDS components to the diffusion map algorithm. The diffusion map function appears to give different results regardless if you 6'set a seed' which is why I save the object after I have ran it a few times and the result has 'stabilized'.

[diffusion maps - destiny package]: (https://github.com/theislab/destiny/blob/master/vignettes/Diffusion-Map-recap.ipynb)

```{r fig.width=9, fig.height=5}
############ DIFFUSION MAP #############
#ElbowPlot(s)
dm <- DiffusionMap(sce, n_pcs=3)
dm.mds <- DiffusionMap(mds.df, vars=1:5)
#dm.mds <- readRDS(paste0(root, '/new_SCE_objects/FINAL_WORKFLOW/trajecetory_obj_5_mds.rds'))
#dm <- readRDS(paste0(root, '/new_SCE_objects/FINAL_WORKFLOW/trajecetory_obj_1_pc6.rds'))

## DM with mds ##
#png(paste0(root, '/new_visualisations/FINAL_WORKFLOW/trajectory_plot_5mds.png'))
par(mfrow=c(1,2))
plot(dm.mds,c(1,3,2),pch = 20,legend_main = 'Timepoint', main='DM from MDS', col_by='sample')
## DM with PCA ##
#png(paste0(root, '/new_visualisations/FINAL_WORKFLOW/trajectory_plot_6pcs.png'))
plot(dm,c(1,3,2),pch = 20,legend_main = 'Timepoint', main='DM from PCA', col_by='sample')
```

Here we do some plots using the diffusion map generated from MDS components of MDS

```{r fig.width=10, fig.height=5}
## DM with MDS
## data frame of pseudotime and DM components ##
df <- data.frame(DC1=eigenvectors(dm.mds)[,1], DC2=eigenvectors(dm.mds)[,2], 
      DC3=eigenvectors(dm.mds)[,3], pseudotime=DPT(dm.mds)$dpt, time=sce$sample, day=sce$day)
p3 <- ggplot(df, aes(x=DC1, y=DC3)) + geom_point(aes(color=day)) + 
  coord_fixed(1) +
  scale_colour_manual(values=c(cc[1], cc[2], cc[3], cc[4], cc[5], cc[6], cc[7]), 
  guide = guide_legend(override.aes = list(size = 5), title='Timepoint'))
p2 <- ggplot(df, aes(x=DC1, y=DC3)) + geom_point(aes(color=time)) +
  coord_fixed(1) +
  scale_colour_manual(values=c(cc[1], cc[2], cc[3], cc[4], cc[5], cc[6], cc[7]), 
  guide = guide_legend(override.aes = list(size = 5), title='Timepoint'))
cowplot::plot_grid(p3,p2)
#cowplot::plot_grid(p2,p4, p1, p3)
#ggsave(paste0(root, '/new_visualisations/FINAL_WORKFLOW/trajectory_5mds_batch.png'), width=10, height=7)
#plot_ly(data = df, x=df$DC1, y=df$DC3, z=df$DC2, type="scatter3d", mode="markers", color=df$time, size = 2)

```

Here we do the same plots as previously, instead using the diffusion map generated by PCA components

```{r}
#DM with PCA
df <- data.frame(DC1=eigenvectors(dm)[,1], DC2=eigenvectors(dm)[,2], 
      DC3=eigenvectors(dm)[,3], pseudotime=DPT(dm)$dpt, time=sce$sample)
p1 <- ggplot(df, aes(x=DC1, y=DC2)) + geom_point(aes(color=time)) +
  coord_fixed(1) +
  scale_colour_manual(values=c(cc[1], cc[2], cc[3], cc[4], cc[5], cc[6], cc[7]), 
  guide = guide_legend(override.aes = list(size = 3), title='Timepoint'))
p2 <- ggplot(df, aes(x=DC1, y=DC3, z=DC2)) + geom_point(aes(color=time)) +
  coord_fixed(1)  +
  scale_colour_manual(values=c(cc[1], cc[2], cc[3], cc[4], cc[5], cc[6], cc[7]), 
  guide = guide_legend(override.aes = list(size = 3), title='Timepoint'))
cowplot::plot_grid(p1,p2)
#ggsave(paste0(root, '/new_visualisations/FINAL_WORKFLOW/trajectory_pca_6pcs.png'), width=10, height=7)
## 3d plot check ##
#plot_ly(data = df, x=df$DC1, y=df$DC3, z=df$DC2, type="scatter3d", mode="markers", color=df$time, size = 2)
cowplot::plot_grid(p1,p2)
```

When you calculate produce a diffusion map the pseudotime is calculated. The pseudotime is baisically the cells ordered across certain lineages which are defined by changes in gene expression profiles. Here we wanted to see if performing DE across pseudotime gave the same DE genes as when DE analysis was performed acoss time. If correct, we could more confidently say that we were detecting biologically relevant changes from two different methods corroborating each other.

```{r }
#### PSEUDOTIME VS TIME ####
p1 <- ggplot(df,aes(x=as.numeric(factor(time, levels=c('2h','8h','16h','24h','48h','72h', '0h'))), y=as.numeric(-pseudotime))) +  
  geom_point() +
  geom_smooth(method='loess', se=F) +
  scale_x_continuous(name='Time', breaks=c(1,2,3,4,5,6,7), labels=c('2h','8hr','16h','24h', '48h', '72h', '0h')) + 
  labs(y='Pseudotime')
#ggsave(paste0(root, '/new_visualisations/FINAL_WORKFLOW/pseudotime_loessmds5.png'), width=7, height=7)
df$pseudorank <- rank(-df$pseudotime)
library(ggbeeswarm)
library(ggthemes)
p2 <- ggplot(as.data.frame(df), 
  aes(x = pseudorank, 
  y = factor(time, levels=c('2h','8h','16h','24h','48h','72h', '0h')), colour = time)) +
  geom_quasirandom(groupOnX = FALSE, size=2) +
  scale_color_tableau()+
  xlab("Diffusion map pseudotime (rank(dpt))") +
  ylab("Timepoint") +
  scale_colour_manual(values=c(cc[1], cc[2], cc[3], cc[4], cc[5], cc[6], cc[7]), 
  guide = guide_legend(override.aes = list(size = 3), title='Timepoint'))
cowplot::plot_grid(p1,p2)
#ggsave(paste0(root, '/new_visualisations/FINAL_WORKFLOW/pseudotime_orderedmds5.png'), width=7, height=7)
```

## Slingshot

Slingshot is another pseudotime algorithm to destiny used above. We run slingshot on the diffusion map components and then plot the 2 lineages identified on the diffusion map.

```{r fig.width=10,warning=FALSE, message=FALSE}
#################### SLINGSHOT #######################
s[["DM"]] <- CreateDimReducObject(embeddings = dm.mds@eigenvectors, key = "DM_", assay = DefaultAssay(s))
sce <- as.SingleCellExperiment(s)
reducedDim(sce, 'DM') <- reducedDim(sce, 'DM')[, 1:10]
sce <- suppressWarnings(slingshot(
  sce,
  reducedDim = 'DM', 
  clusterLabels = 'sample'
))
sds <- SlingshotDataSet(sce)
#png(paste0(root, '/new_visualisations/FINAL_WORKFLOW/slingshot_diff.png'))


## plot both lineages ##
#png(paste0(root, '/new_visualisations/FINAL_WORKFLOW/slingshot_lineages.png'))
par(mfrow=c(1,3))
## first lineage 2,8, 6,24,48, 0
## plot trajectories ##
plot(reducedDims(sce)$DM, col = cc[sce$sample], pch=16)
lines(SlingshotDataSet(sce), lwd=1, col='black')
legend('topright',legend=unique(colData(sce)$sample), fill=cc[as.integer(unique(colData(sce)$sample))])
plot(reducedDims(sce)$DM, col = cc[sce$sample], pch=16, asp=1)
lines(sds, linInd=1)
legend('topright',legend=unique(colData(sce)$sample), fill=cc[as.integer(unique(colData(sce)$sample))])
## second lineage 2,8,16,34,48,72
plot(reducedDims(sce)$DM, col = cc[sce$sample], pch=16, asp=1)
lines(sds, linInd=2)
legend('topright',legend=unique(colData(sce)$sample), fill=cc[as.integer(unique(colData(sce)$sample))])

```

We can also plot the pseudotime overlaid onto the diffusion map

```{r}
#### plot psuedotime ####
#png(paste0(root, '/new_visualisations/FINAL_WORKFLOW/slingshot_pseudotime.png'))
par(mfrow=c(1,2))
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce$slingPseudotime_1, breaks=100)]
plot(reducedDims(sce)$DM, col = plotcol, pch=16)
lines(SlingshotDataSet(sce), lwd=2, col='black')
plotcol <- colors[cut(sce$slingPseudotime_2, breaks=100)]
plot(reducedDims(sce)$DM, col = plotcol, pch=16)
lines(SlingshotDataSet(sce), lwd=2, col='black')
```


## pseudotime differential expression analysis

When we have calculated the pseudotime we can perform differential expression analysis across pseudotime. This works differently to DE analysis as we can't average or aggregate the counts for each group as pseudotime is a continuous process. Instead we have to use a generative additive model which 'looks' at the expression of each gene across pseudotime. 

The same processes regarding pvalue adjusting apply. [good pseudotime tutorial]:(https://broadinstitute.github.io/2019_scWorkshop/pseudotime-cell-trajectories.html)

We also identify the common genes detected from DE analysis across time and DE analysis across pseudotime

```{r warning FALSE, message=FALSE}
ptime <- sce$slingPseudotime_1
## remove cells that arnt in lineage i.e. most of control ##
lineage_cells <- colnames(sce)[!is.na(ptime)]
ptime <- ptime[!is.na(ptime)]
library(gam)
gam.pval <- apply(counts[,lineage_cells], 1, function(z){
  d <- data.frame(z = z, ptime = ptime)
  tmp <- suppressWarnings(gam(z ~ lo(ptime), data=d))
  p <- summary(tmp)[4][[1]][1, 5]
  p
})

### adjust pvalues ###
res <- tibble(
  id = names(gam.pval),
  pvals = gam.pval,
  qval = p.adjust(gam.pval, method = "fdr")) 
top100.g <- res %>% arrange(qval) %>% slice_head(n=100)

## write top 1000 genes to file ##
annotations <- load_annotations()
top100.p <- res %>% top_n(qval, n=1000) %>% 
  dplyr::rename(gene_name=id) %>% 
  left_join(., annotations, by='gene_name')
#write.csv(top100.p, paste0(root, '/new_tables/FINAL_WORKFLOW/top100_slingshotpseudotime1.csv'))

## top genes ##
top.genes <- gam.pval[order(gam.pval)][1:100] ## 39/100 common deg amongst top 100 genes by pvalua
common <- intersect(top100.t$gene, names(top.genes)) 
common <- annotations[annotations$gene_name %in% common,]
#write.csv(common, paste0(root, '/new_tables/FINAL_WORKFLOW/common_deg_slingshotpseudotime1.csv'))

```

Then we can plot a heatmap of all the top most signifcant genes across pseudotime. Making sure to organise the columns in order of pseudotime. Labelling the common DEG detected from DE analysis across time and DE analysis across pseudotime.

```{r }
## try with complex heatmap ##
heatclus <- s$sample[order(ptime, na.last = NA)]
heatdata <- as.matrix(counts[names(top.genes), order(ptime, na.last = NA)])
vcc <- viridis::viridis_pal()(12)
ha.anno <- HeatmapAnnotation(df=as.data.frame(heatclus), 
  col = list(heatclus=c('0h'=cc[1], '2h'=cc[2],'8h'=cc[3],'16h'=cc[4],'24h'=cc[5],'48h'=cc[6],'72h'=cc[7])))
#png(paste0(root, '/new_visualisations/FINAL_WORKFLOW/slingshot_pseudotime1_complex_heatmap.png'))
Heatmap(heatdata, top_annotation = ha.anno, 
     name= 'Expression',
     col = colorRamp2(c(-2, 0, 2), c("#440154FF", "#2D708EFF", "#FDE725FF")),
     cluster_columns = F, 
     show_column_names = F) +
  rowAnnotation(link=anno_mark(at = which(rownames(heatdata) %in% common$gene_name),
  labels = (rownames(heatdata)[rownames(heatdata) %in% common$gene_name]), 
  labels_gp = gpar(fontsize = 9, col='black'), padding = unit(0.3, "mm")))
```

